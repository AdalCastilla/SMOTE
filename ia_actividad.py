# -*- coding: utf-8 -*-
"""IA actividad.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1x3Oh-8UsgqYiYtWQPYKGzwrjffwBE8Pe
"""

# Importar las librerías necesarias
import pandas as pd
import matplotlib.pyplot as plt
from sklearn.model_selection import train_test_split
from sklearn.linear_model import LogisticRegression
from sklearn.metrics import classification_report
from imblearn.over_sampling import SMOTE

# Ruta al archivo CSV (asegúrate de que sea accesible desde Colab o tu entorno)
data_path = r"/creditcard.csv"

# Cargar los datos
data_kaggle = pd.read_csv(data_path)

# Asegurarte de que las columnas relevantes están presentes
# Ajusta "Feature1", "Feature2", y "Target" según las columnas de tu dataset
if set(["V1", "V2", "Class"]).issubset(data_kaggle.columns):  # Ejemplo para dataset de fraude
    # Seleccionar características y objetivo
    data = data_kaggle[["V1", "V2", "Class"]]  # Cambia según las columnas relevantes
    data.columns = ["Feature1", "Feature2", "Target"]  # Renombrar para mantener consistencia

    # Visualización inicial
    print("Distribución de las clases:")
    print(data["Target"].value_counts())
    plt.scatter(data["Feature1"], data["Feature2"], c=data["Target"], cmap="coolwarm", alpha=0.6)
    plt.title("Distribución del conjunto de datos (Kaggle)")
    plt.xlabel("Feature1")
    plt.ylabel("Feature2")
    plt.show()

    # Dividir los datos en entrenamiento y prueba
    X_train, X_test, y_train, y_test = train_test_split(data[["Feature1", "Feature2"]],
                                                        data["Target"], test_size=0.3, random_state=42)

    # Entrenar el modelo sin balanceo
    model = LogisticRegression()
    model.fit(X_train, y_train)
    y_pred = model.predict(X_test)
    print("Reporte de clasificación (modelo desbalanceado):")
    print(classification_report(y_test, y_pred))

    # Aplicar SMOTE para balancear los datos
    smote = SMOTE(random_state=42)
    X_resampled, y_resampled = smote.fit_resample(X_train, y_train)

    # Entrenar el modelo con datos balanceados
    model.fit(X_resampled, y_resampled)
    y_pred_resampled = model.predict(X_test)
    print("Reporte de clasificación (modelo balanceado):")
    print(classification_report(y_test, y_pred_resampled))
else:
    print("El dataset no tiene las columnas esperadas.")